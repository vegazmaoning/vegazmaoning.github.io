layout:     post
title:      CPU调度
date:       2020/4/4
author:     Vegaz
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Linux

CPU中断与上下文切换

进程上下文切换：

 	1. 无法获取资源，自愿放弃cpu
 	2. 被系统强制调度产生的切换

### 系统调用

进程从用户态要进入到内核态， 需要经过系统调用，比如打开并读取一个文件，中间经过的系统调用有open, read, close 等。

所经历的过程为：

1. cpu保存用户态进程的指令位(寄存器）

2. cpu寄存器更新为内核态指令的位置

3. 跳转到内核态运行

4. 系统调用完成后， 恢复原来的用户进程， 进入到用户态

   所以一次系统调用，需要经历两次CPU上下文切换(用户态>内核态>用户态)

系统调用的过程中，不会切换进程，这里和我们说的进程上下文切换是不一样的，进程上下文切换是指从一个进程切换到另一个进程。所以系统调用通常称为特权模式切换， 而不是上下文切换，系统调用属于同进程内的cpu上下文切换。

### 进程切换和系统调用的区别

进程切换的场景：

1. cpu时间片结束， cpu是划分多个时间片给不同的进程使用
2. 进程运行的资源不够， 比如IO、内存分配等，进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行
3. 进程主动挂起， 比如sleep
4. 有优先级更高的进程， 如硬中断。对同一个 `CPU` 来说，中断处理比进程拥有更高的优先级，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束

